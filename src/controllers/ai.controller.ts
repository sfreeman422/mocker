import express, { Router } from 'express';
import { SlashCommandRequest } from '../shared/models/slack/slack-models';
import { SuppressorService } from '../shared/services/suppressor.service';
import { KnownBlock } from '@slack/web-api';
import { AIService } from '../services/ai/ai.service';
import { WebService } from '../services/web/web.service';
import { StoreService } from '../services/store/store.service';

export const aiController: Router = express.Router();

const webService = WebService.getInstance();
const suppressorService = new SuppressorService();
const aiService = new AIService();
const storeService = new StoreService();

const getChunks = (text: string): string[] => {
  let characterCount = 0;
  let currentChunk = 0;
  const chunks: string[] = [];

  text.split(' ').forEach(word => {
    characterCount += word.length + 1;
    if (characterCount >= 2920) {
      characterCount = word.length + 1;
      chunks.push(`${word} `);
      currentChunk += 1;
    } else if (!chunks[currentChunk]) {
      chunks[currentChunk] = `${word} `;
    } else {
      chunks[currentChunk] += `${word} `;
    }
  });

  return chunks;
};

aiController.post('/ai/text', async (req, res) => {
  const request: SlashCommandRequest = req.body;
  // Hardcoded 4 for Moon Token Item Id.
  const hasAvailableMoonToken = await storeService.isItemActive(request.user_id, request.team_id, 4);
  const isAlreadyAtMaxRequests = await aiService.isAlreadyAtMaxRequests(request.user_id, request.team_id);

  if (await suppressorService.isSuppressed(request.user_id, request.team_id)) {
    res.send(`Sorry, can't do that while muzzled.`);
  } else if (!request.text) {
    res.send('Sorry, you must send a message to generate text.');
  } else if (request.text.length >= 800) {
    res.send('Sorry, your request cannot be more than 800 characters. Please refine your query.');
  } else if (await aiService.isAlreadyInflight(request.user_id, request.team_id)) {
    res.send('Sorry, you already have a request in flight. Please wait for that request to complete.');
    // Check here if they also have available moon tokens.
  } else if (isAlreadyAtMaxRequests && !hasAvailableMoonToken) {
    res.send(
      'Sorry, you have reached your maximum number of requests per day. Try again tomorrow or consider purchasing a Moon Token in the store.',
    );
  } else {
    // Need to do this to avoid timeout issues.
    res.status(200).send('Processing your request. Please be patient...');
    const generatedText: string | undefined = await aiService
      .generateText(request.user_id, request.team_id, request.text)
      .catch(e => {
        console.error(e);
        const errorMessage = `\`Sorry! Your request for ${request.text} failed. Please try again.\``;
        webService.sendEphemeral(request.channel_id, errorMessage, request.user_id);
        return undefined;
      });

    if (!generatedText) {
      return;
    }

    const blocks: KnownBlock[] = [];

    const chunks = getChunks(generatedText);

    if (chunks) {
      chunks.forEach(chunk => {
        console.log(chunk.length);
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `${chunk}`,
          },
        });
      });
    }

    blocks.push({
      type: 'divider',
    });

    blocks.push({
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `:receipt: _Generated by <@${request.user_id}> | "${request.text}"_ :receipt:`,
        },
      ],
    });

    console.log(blocks);
    webService.sendMessage(request.channel_id, request.text, blocks).catch(e => {
      console.error(e);
      aiService.decrementDaiyRequests(request.user_id, request.team_id);
      webService.sendMessage(
        request.user_id,
        'Sorry, unable to send the requested text to Slack. You have been credited for your Moon Token. Perhaps you were trying to send in a private channel? If so, invite @MoonBeam and try again.',
      );
    });

    if (isAlreadyAtMaxRequests && hasAvailableMoonToken) {
      storeService.removeEffect(request.user_id, request.team_id, 4);
    }
  }
});

aiController.post('/ai/image', async (req, res) => {
  const request: SlashCommandRequest = req.body;
  // Hardcoded 4 for Moon Token Item Id.
  const hasAvailableMoonToken = await storeService.isItemActive(request.user_id, request.team_id, 4);
  const isAlreadyAtMaxRequests = await aiService.isAlreadyAtMaxRequests(request.user_id, request.team_id);

  if (await suppressorService.isSuppressed(request.user_id, request.team_id)) {
    res.send(`Sorry, can't do that while muzzled.`);
  } else if (!request.text) {
    res.send('Sorry, you must send a message to generate text.');
  } else if (request.text.length >= 800) {
    res.send('Sorry, your request cannot be more than 800 characters. Please refine your query.');
  } else if (await aiService.isAlreadyInflight(request.user_id, request.team_id)) {
    res.send('Sorry, you already have a request in flight. Please wait for that request to complete.');
  } else if (isAlreadyAtMaxRequests && !hasAvailableMoonToken) {
    res.send(
      'Sorry, you have reached your maximum number of requests per day. Try again tomorrow, or consider purchasing a Moon Token in the store.',
    );
  } else {
    // Need to do this to avoid timeout issues.
    res.status(200).send('Processing your request. Please be patient...');
    const generatedImage = await aiService.generateImage(request.user_id, request.team_id, request.text).catch(e => {
      console.error(e);
      const errorMessage = `\`Sorry! Your request for ${request.text} failed. Please try again.\``;
      webService.sendEphemeral(request.channel_id, errorMessage, request.user_id);
      return undefined;
    });

    if (!generatedImage) {
      return;
    }

    const blocks: KnownBlock[] = [
      {
        type: 'image',
        // eslint-disable-next-line @typescript-eslint/camelcase
        image_url: generatedImage,
        // eslint-disable-next-line @typescript-eslint/camelcase
        alt_text: request.text,
      },
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `:camera_with_flash: _Generated by <@${request.user_id}> | "${request.text}"_ :camera_with_flash:`,
          },
        ],
      },
    ];
    webService.sendMessage(request.channel_id, request.text, blocks).catch(e => {
      console.error(e);
      aiService.decrementDaiyRequests(request.user_id, request.team_id);
      webService.sendMessage(
        request.user_id,
        'Sorry, unable to send the requested image to Slack. You have been credited for your Moon Token. Perhaps you were trying to send in a private channel? If so, invite @MoonBeam and try again.',
      );
    });
    if (isAlreadyAtMaxRequests && hasAvailableMoonToken) {
      storeService.removeEffect(request.user_id, request.team_id, 4);
    }
  }
});
